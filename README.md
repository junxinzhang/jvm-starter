# Java内存管理与垃圾收集器

Java作为一种广泛使用的编程语言，其高效的内存管理是保证应用性能的关键。以下深入了解Java中的内存管理机制和垃圾收集器的工作原理。

## 内存分配与异常处理
在Java虚拟机（JVM）中，内存管理是一个核心部分。特别地，在单个线程中，可能会遇到两种常见的内存分配相关异常：

- **StackOverflowError**: 当线程请求的栈深度超过JVM所允许的深度时抛出。通常这是递归调用过深导致的。
- **OutOfMemoryError**: 当JVM没有足够的内存分配给对象时抛出，可能是由于堆内存太小或内存泄漏导致。

## 引用计数算法
引用计数算法是最简单的垃圾收集（GC）算法之一，其工作原理如下：

- 每个对象都包含一个引用计数器。
- 当有一个新的引用指向该对象时，计数器加1。
- 当引用失效时，计数器减1。
- 当任何时刻计数器为0时，表示对象不再被使用，可以被GC回收。

**缺点**：这种方法无法处理循环引用的情况，例如两个对象相互引用。

## 垃圾收集算法
Java中采用了几种不同的垃圾收集算法，每种算法都有其特点和适用场景：

- **标记 - 清除算法**：此算法分为"标记"和"清除"两个阶段。首先标记出所有需要回收的对象，然后统一回收这些对象。
- **复制算法**：将内存划分为两块相同大小的区域。每次只使用其中一块。当这一块的内存用完了，就将活着的对象复制到另一块上，然后清理掉已使用的内存块。
- **标记 - 整理算法**：此算法在标记阶段和标记-清除算法相同，但在清除阶段，它会将所有活着的对象压缩到内存的一端，然后清理掉边界以外的内存。
- **分代收集算法**：根据对象的存活周期，将内存分为年轻代和老年代。不同的代使用不同的GC算法。

## 垃圾收集器
Java提供了多种垃圾收集器，每个收集器都有其特定的使用场景和性能特点：

### Serial收集器
- **类型**：单线程收集器。
- **特点**：简单而高效（在单线程环境下）。进行垃圾收集时需要暂停所有工作线程（Stop-The-World）。
- **适用场景**：适合单核处理器或小型堆内存的环境。

### ParNew收集器
- **类型**：Serial收集器的多线程版本。
- **特点**：多线程收集，但垃圾收集时同样需要暂停所有工作线程。
- **适用场景**：多核处理器和少量并行垃圾收集需求的场景。

### Parallel Scavenge收集器
- **类型**：一个以达到可控制的吞吐量（Throughput）为目标的收集器。
- **特点**：并行的收集器，注重吞吐量和CPU资源的有效利用。
- **适用场景**：注重服务的响应速度和处理量的场景。

### Serial Old收集器
- **类型**：Serial收集器的老年代版本。
- **特点**：单线程，使用标记-整理算法，适用于老年代垃圾收集。
- **适用场景**：单核处理器或小型堆内存的老年代垃圾收集。

### Parallel Old收集器
- **类型**：Parallel Scavenge收集器的老年代版本。
- **特点**：多线程，使用标记-整理算法。
- **适用场景**：在多核环境下，与Parallel Scavenge收集器搭配使用，提高老年代垃圾收集效率。

### CMS (Concurrent Mark Sweep) 收集器
- **目标**：最短回收停顿时间。
- **特点**：并发收集，低停顿。
- **工作流程**：
  - 初始标记（CMS initial mark）
  - 并发标记（CMS concurrent mark）
  - 重新标记（CMS remark）
  - 并发清除（CMS concurrent sweep）
- **适用场景**：适用于注重服务响应时间和减少停顿时间的应用。

### G1收集器
- **类型**：使用标记-整理算法，面向服务端应用。
- **特点**：在提供高吞吐量的同时，能够更精确地控制停顿时间，适合大内存应用。
- **适用场景**：大型应用和服务端应用，特别是具有大量内存和多核CPU的系统。

